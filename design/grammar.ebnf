program = import? declaration* EOF;
import = "import" IDENTIFIER;
declaration = (typeDecl | functionsDecl | interfaceDecl | operatorsDecl | propertiesDecl | funcDecl | variableDecl | statement);

(* Declarations *)
typeDecl = "type" IDENTIFIER [typeInheritence | unionDeclaration] ";";
typeInheritence = ":" IDENTIFIER ["," IDENTIFIER]*;
unionDeclaration = "=" IDENTIFIER ["|" IDENTIFIER]*;

functionsDecl = [visibility]? "functions" "of" IDENTIFIER "{" function* "}";
interfaceDecl = [visibility]? "interface" "of" IDENTIFIER "{" interface* "}";
operatorsDecl = [visibility]? "operator" "of" IDENTIFIER "{" operator* "}";
propertiesDecl = [visibility]? "properties" "of" IDENTIFIER "{" property "}";

funcDecl = [visibility]? "func" function;
returnDef = ":" IDENTIFIER;

variableDecl = varDecl | letDecl;
varDecl = "var" IDENTIFIER ["=" expression] ";";
letDecl = "let" IDENTIFIER ["=" expression] ";";

(* Statements *)
statement = exprStmt | forStmt | ifStmt | returnStmt | whileStmt | block;
exprStmt = expression ";";
forStmt = "for" "(" (varDecl | expression | ";") expression? ";" expression? ")" block;
ifStmt = "if" "(" expression ")" block ["else" block];
returnStmt = "return" [expression] ";";
whileStmt = "while" "(" expression ")" block;
block = "{" declaration* "}";

(* Expressions *)
expression = assignment;
assignment = (call .)? IDENTIFIER "=" assignment | logic_or;
logic_or = logic_and ("or" logic_and)*;
logic_and = equality ("and" equality)*;
equality = comparison (("!=" | "==") comparison)*;
comparison = term ((">" | ">=" | "<" | "<=") term)*;
term = factor (("-" | "+") factor)*;
factor = unary (("/" | "*") unary)*;
unary = ("!" | "-") unary | call;
call = "."? primary ("(" arguments? ")" | "." IDENTIFIER)*;
primary = "true" | "false" | "nil" | "this" | NUMBER | STRING | IDENTIFIER | "(" expression ")" | "base" "." IDENTIFIER;

(* Utility rules *)
function = IDENTIFIER "(" parameters? ")" [returnDef] block;
interface = IDENTIFIER "(" parameters? ")" [returnDef];
operator = operatorKind IDENTIFIER "(" parameter "," parameter ")" [returnDef] block;

parameters = parameter ["," parameter]*;
parameter = (IDENTIFIER [":" TYPE]?);
arguments = expression ["," expression]*;

visibility = "public" | "protected" | "private";
operatorKind = "prefix" | "infix" | "postfix";

NUMBER = DIGIT+ ("." DIGIT+)?;
STRING = "\"" <any char except '"'>* "\"";
IDENTIFIER = ALPHA (ALPHA | DIGIT)*;
TYPE = IDENTIFIER;
ALPHA = "a"..."z" | "A"..."Z" | "_";
DIGIT = "0" ... "9";
